{"message":"`main` function not found in crate `precedence`","code":{"code":"E0601","explanation":"No `main` function was found in a binary crate.\n\nTo fix this error, add a `main` function:\n\n```\nfn main() {\n    // Your program will start here.\n    println!(\"Hello world!\");\n}\n```\n\nIf you don't know the basics of Rust, you can look at the\n[Rust Book][rust-book] to get started.\n\n[rust-book]: https://doc.rust-lang.org/book/\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":9988,"line_start":1,"line_end":331,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"use std::io::{self, BufRead};","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"mod boolean;","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"use crate::boolean::matrix::{self, Matrix};","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"trait PrecedenceGrammar {","highlight_start":1,"highlight_end":26},{"text":"    fn new() -> Self;","highlight_start":1,"highlight_end":22},{"text":"    fn parse_input(&mut self, compute_handles: bool);","highlight_start":1,"highlight_end":54},{"text":"    fn shrink_precedence(&mut self);","highlight_start":1,"highlight_end":37},{"text":"    fn compute_handles(&mut self);","highlight_start":1,"highlight_end":35},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"struct OPG {","highlight_start":1,"highlight_end":13},{"text":"    first: Matrix,","highlight_start":1,"highlight_end":19},{"text":"    first_term: Matrix,","highlight_start":1,"highlight_end":24},{"text":"    last: Matrix,","highlight_start":1,"highlight_end":18},{"text":"    last_term: Matrix,","highlight_start":1,"highlight_end":23},{"text":"    takes: Matrix,","highlight_start":1,"highlight_end":19},{"text":"    yields: Matrix,","highlight_start":1,"highlight_end":20},{"text":"    equal: Matrix,","highlight_start":1,"highlight_end":19},{"text":"    rtc: Matrix,","highlight_start":1,"highlight_end":17},{"text":"    f: Vec<i32>,","highlight_start":1,"highlight_end":17},{"text":"    g: Vec<i32>,","highlight_start":1,"highlight_end":17},{"text":"    m_dimension: usize,","highlight_start":1,"highlight_end":24},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"struct SPG {","highlight_start":1,"highlight_end":13},{"text":"    first: Matrix,","highlight_start":1,"highlight_end":19},{"text":"    last: Matrix,","highlight_start":1,"highlight_end":18},{"text":"    takes: Matrix,","highlight_start":1,"highlight_end":19},{"text":"    yields: Matrix,","highlight_start":1,"highlight_end":20},{"text":"    equal: Matrix,","highlight_start":1,"highlight_end":19},{"text":"    rtc: Matrix,","highlight_start":1,"highlight_end":17},{"text":"    f: Vec<i32>,","highlight_start":1,"highlight_end":17},{"text":"    g: Vec<i32>,","highlight_start":1,"highlight_end":17},{"text":"    m_dimension: usize,","highlight_start":1,"highlight_end":24},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl OPG {","highlight_start":1,"highlight_end":11},{"text":"    // NOTE: take the (<=) matrix and add to pos [0][7] through pos [7][15]","highlight_start":1,"highlight_end":76},{"text":"    // also take (>=)T matrix and add to pos [8][0] through pos [15][7]","highlight_start":1,"highlight_end":72},{"text":"    // to create the B matrix","highlight_start":1,"highlight_end":30},{"text":"    fn create_b_matrix(&self) -> Matrix{","highlight_start":1,"highlight_end":41},{"text":"        let b_matrix_len = self.m_dimension * 2;","highlight_start":1,"highlight_end":49},{"text":"        let mut b_matrix: Matrix = vec![vec![false; b_matrix_len]; b_matrix_len]; ","highlight_start":1,"highlight_end":83},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let takes_equal = matrix::combine_matrix(&self.takes, &self.equal);","highlight_start":1,"highlight_end":76},{"text":"        let yields_equal = matrix::combine_matrix(&self.yields, &self.equal);","highlight_start":1,"highlight_end":78},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Shadowing takes_equal to perform the transpose","highlight_start":1,"highlight_end":58},{"text":"        let takes_equal = matrix::transpose(&takes_equal);","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        for row in 0..b_matrix_len {","highlight_start":1,"highlight_end":37},{"text":"            for col in 0..b_matrix_len {","highlight_start":1,"highlight_end":41},{"text":"                if row < (b_matrix_len / 2) && col >= (b_matrix_len / 2) {","highlight_start":1,"highlight_end":75},{"text":"                    b_matrix[row][col] = yields_equal[row][col % (self.m_dimension)];","highlight_start":1,"highlight_end":86},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if row >= (b_matrix_len / 2) && col < (b_matrix_len / 2){","highlight_start":1,"highlight_end":74},{"text":"                    b_matrix[row][col] = takes_equal[row % (self.m_dimension)][col % (self.m_dimension)];","highlight_start":1,"highlight_end":106},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        b_matrix","highlight_start":1,"highlight_end":17},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl PrecedenceGrammar for OPG {","highlight_start":1,"highlight_end":33},{"text":"    fn new() -> OPG {","highlight_start":1,"highlight_end":22},{"text":"        OPG {","highlight_start":1,"highlight_end":14},{"text":"            first: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            first_term: Vec::new(),","highlight_start":1,"highlight_end":36},{"text":"            last: Vec::new(),","highlight_start":1,"highlight_end":30},{"text":"            last_term: Vec::new(),","highlight_start":1,"highlight_end":35},{"text":"            takes: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            yields: Vec::new(),","highlight_start":1,"highlight_end":32},{"text":"            equal: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            rtc: Vec::new(),","highlight_start":1,"highlight_end":29},{"text":"            f: Vec::new(),","highlight_start":1,"highlight_end":27},{"text":"            g: Vec::new(),","highlight_start":1,"highlight_end":27},{"text":"            m_dimension: 0,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn parse_input(&mut self, compute_handles: bool) {","highlight_start":1,"highlight_end":55},{"text":"        let in_handle = io::stdin();","highlight_start":1,"highlight_end":37},{"text":"        let mut lines = in_handle.lock().lines();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut matrix: Matrix = Vec::new();","highlight_start":1,"highlight_end":45},{"text":"        let mut count: i32 = 0;","highlight_start":1,"highlight_end":32},{"text":"        while let Some(line) = lines.next() {","highlight_start":1,"highlight_end":46},{"text":"            let line_ref = line.unwrap();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if line_ref.is_empty() {","highlight_start":1,"highlight_end":37},{"text":"                continue;","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let mut m_size = line_ref.split(' ');","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let (x, y) = (","highlight_start":1,"highlight_end":27},{"text":"                m_size.next().unwrap().parse::<i32>().ok().unwrap(),","highlight_start":1,"highlight_end":69},{"text":"                m_size.next().unwrap().parse::<i32>().ok().unwrap(),","highlight_start":1,"highlight_end":69},{"text":"            );","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if x != y {","highlight_start":1,"highlight_end":24},{"text":"                panic!(\"Please supply a valid square matrix.\");","highlight_start":1,"highlight_end":64},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            self.m_dimension = x as usize;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            for _ in 0..x {","highlight_start":1,"highlight_end":28},{"text":"                matrix.push(","highlight_start":1,"highlight_end":29},{"text":"                    lines","highlight_start":1,"highlight_end":26},{"text":"                        .next()","highlight_start":1,"highlight_end":32},{"text":"                        .unwrap()","highlight_start":1,"highlight_end":34},{"text":"                        .unwrap()","highlight_start":1,"highlight_end":34},{"text":"                        .trim()","highlight_start":1,"highlight_end":32},{"text":"                        .split_whitespace()","highlight_start":1,"highlight_end":44},{"text":"                        .map(|x| -> bool {","highlight_start":1,"highlight_end":43},{"text":"                            match x.parse::<u32>().ok().unwrap() {","highlight_start":1,"highlight_end":67},{"text":"                                0 => false,","highlight_start":1,"highlight_end":44},{"text":"                                1 => true,","highlight_start":1,"highlight_end":43},{"text":"                                _ => panic!(\"[ Error ] Ouch found something not allowed.\"),","highlight_start":1,"highlight_end":92},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<bool>>(),","highlight_start":1,"highlight_end":49},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"           ","highlight_start":1,"highlight_end":12},{"text":"            if compute_handles {","highlight_start":1,"highlight_end":33},{"text":"                match count {","highlight_start":1,"highlight_end":30},{"text":"                    0 => self.first = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    1 => self.first_term = matrix.clone(),","highlight_start":1,"highlight_end":59},{"text":"                    2 => self.last = matrix.clone(),","highlight_start":1,"highlight_end":53},{"text":"                    3 => self.last_term = matrix.clone(),","highlight_start":1,"highlight_end":58},{"text":"                    4 => self.equal = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    _ => panic!(\"[ ERROR ] Included too many matrices in input.\"),","highlight_start":1,"highlight_end":83},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                match count {","highlight_start":1,"highlight_end":30},{"text":"                    0 => self.takes = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    1 => self.yields = matrix.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    2 => self.equal = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    _ => panic!(\"[ ERROR ] Included too many matrices in input.\"),","highlight_start":1,"highlight_end":83},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            matrix.clear();","highlight_start":1,"highlight_end":28},{"text":"            count += 1;","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn shrink_precedence(&mut self) {","highlight_start":1,"highlight_end":38},{"text":"        let length = self.rtc.len();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut count = 0;","highlight_start":1,"highlight_end":27},{"text":"        for row in 0..length {","highlight_start":1,"highlight_end":31},{"text":"            if row < (length / 2) {","highlight_start":1,"highlight_end":36},{"text":"                for col in 0..length {","highlight_start":1,"highlight_end":39},{"text":"                    if self.rtc[row][col] {","highlight_start":1,"highlight_end":44},{"text":"                        count += 1;","highlight_start":1,"highlight_end":36},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                self.f.push(count);","highlight_start":1,"highlight_end":36},{"text":"                count = 0;","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if row >= (length / 2) {","highlight_start":1,"highlight_end":37},{"text":"                for col in 0..length {","highlight_start":1,"highlight_end":39},{"text":"                    if self.rtc[row][col] {","highlight_start":1,"highlight_end":44},{"text":"                        count += 1;","highlight_start":1,"highlight_end":36},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                self.g.push(count);","highlight_start":1,"highlight_end":36},{"text":"                count = 0;","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn compute_handles(&mut self) {","highlight_start":1,"highlight_end":36},{"text":"        let mut final_handle: Matrix;","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let first_p = matrix::transitive_closure(&self.first);","highlight_start":1,"highlight_end":63},{"text":"        let identity = matrix::create_identity(10); ","highlight_start":1,"highlight_end":53},{"text":"        let first_s = matrix::sum(&identity, &first_p);","highlight_start":1,"highlight_end":56},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        final_handle = matrix::product(&self.equal, &first_s);","highlight_start":1,"highlight_end":63},{"text":"        final_handle = matrix::product(&final_handle, &self.first_term);","highlight_start":1,"highlight_end":73},{"text":"        self.takes = final_handle.clone();","highlight_start":1,"highlight_end":43},{"text":"        final_handle.clear();","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let last_p = matrix::transitive_closure(&self.last);","highlight_start":1,"highlight_end":61},{"text":"        let last_s = matrix::sum(&identity, &last_p);","highlight_start":1,"highlight_end":54},{"text":"        final_handle = matrix::product(&last_s, &self.last_term);","highlight_start":1,"highlight_end":66},{"text":"        final_handle = matrix::transpose(&final_handle);","highlight_start":1,"highlight_end":57},{"text":"        final_handle = matrix::product(&final_handle, &self.equal);","highlight_start":1,"highlight_end":68},{"text":"        self.yields = final_handle.clone();","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl PrecedenceGrammar for SPG {","highlight_start":1,"highlight_end":33},{"text":"    fn new() -> SPG {","highlight_start":1,"highlight_end":22},{"text":"        SPG {","highlight_start":1,"highlight_end":14},{"text":"            first: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            last: Vec::new(),","highlight_start":1,"highlight_end":30},{"text":"            takes: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            yields: Vec::new(),","highlight_start":1,"highlight_end":32},{"text":"            equal: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            rtc: Vec::new(),","highlight_start":1,"highlight_end":29},{"text":"            f: Vec::new(),","highlight_start":1,"highlight_end":27},{"text":"            g: Vec::new(),","highlight_start":1,"highlight_end":27},{"text":"            m_dimension: 0","highlight_start":1,"highlight_end":27},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn parse_input(&mut self, compute_handles: bool) {","highlight_start":1,"highlight_end":55},{"text":"        let in_handle = io::stdin();","highlight_start":1,"highlight_end":37},{"text":"        let mut lines = in_handle.lock().lines();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut matrix: Matrix = Vec::new();","highlight_start":1,"highlight_end":45},{"text":"        let mut count: i32 = 0;","highlight_start":1,"highlight_end":32},{"text":"        while let Some(line) = lines.next() {","highlight_start":1,"highlight_end":46},{"text":"            let line_ref = line.unwrap();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if line_ref.is_empty() {","highlight_start":1,"highlight_end":37},{"text":"                continue;","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let mut m_size = line_ref.split(' ');","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let (x, y) = (","highlight_start":1,"highlight_end":27},{"text":"                m_size.next().unwrap().parse::<i32>().ok().unwrap(),","highlight_start":1,"highlight_end":69},{"text":"                m_size.next().unwrap().parse::<i32>().ok().unwrap(),","highlight_start":1,"highlight_end":69},{"text":"            );","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if x != y {","highlight_start":1,"highlight_end":24},{"text":"                panic!(\"Please supply a valid square matrix.\");","highlight_start":1,"highlight_end":64},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            self.m_dimension = x as usize;","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            for _ in 0..x {","highlight_start":1,"highlight_end":28},{"text":"                matrix.push(","highlight_start":1,"highlight_end":29},{"text":"                    lines","highlight_start":1,"highlight_end":26},{"text":"                        .next()","highlight_start":1,"highlight_end":32},{"text":"                        .unwrap()","highlight_start":1,"highlight_end":34},{"text":"                        .unwrap()","highlight_start":1,"highlight_end":34},{"text":"                        .trim()","highlight_start":1,"highlight_end":32},{"text":"                        .split_whitespace()","highlight_start":1,"highlight_end":44},{"text":"                        .map(|x| -> bool {","highlight_start":1,"highlight_end":43},{"text":"                            match x.parse::<u32>().ok().unwrap() {","highlight_start":1,"highlight_end":67},{"text":"                                0 => false,","highlight_start":1,"highlight_end":44},{"text":"                                1 => true,","highlight_start":1,"highlight_end":43},{"text":"                                _ => panic!(\"[ Error ] Ouch found something not allowed.\"),","highlight_start":1,"highlight_end":92},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<bool>>(),","highlight_start":1,"highlight_end":49},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            if compute_handles {","highlight_start":1,"highlight_end":33},{"text":"                match count {","highlight_start":1,"highlight_end":30},{"text":"                    0 => self.first = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    1 => self.last = matrix.clone(),","highlight_start":1,"highlight_end":53},{"text":"                    2 => self.equal = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    _ => panic!(\"[ ERROR ] Included too many matrices in input.\"),","highlight_start":1,"highlight_end":83},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                match count {","highlight_start":1,"highlight_end":30},{"text":"                    0 => self.takes = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    1 => self.yields = matrix.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    2 => self.equal = matrix.clone(),","highlight_start":1,"highlight_end":54},{"text":"                    _ => panic!(\"[ ERROR ] Included too many matrices in input.\"),","highlight_start":1,"highlight_end":83},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            matrix.clear();","highlight_start":1,"highlight_end":28},{"text":"            count += 1;","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } ","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn shrink_precedence(&mut self) {","highlight_start":1,"highlight_end":38},{"text":"        let length = self.rtc.len();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut count = 0;","highlight_start":1,"highlight_end":27},{"text":"        for row in 0..length {","highlight_start":1,"highlight_end":31},{"text":"            if row < (length / 2) {","highlight_start":1,"highlight_end":36},{"text":"                for col in 0..length {","highlight_start":1,"highlight_end":39},{"text":"                    if self.rtc[row][col] {","highlight_start":1,"highlight_end":44},{"text":"                        count += 1;","highlight_start":1,"highlight_end":36},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                self.f.push(count);","highlight_start":1,"highlight_end":36},{"text":"                count = 0;","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if row >= (length / 2) {","highlight_start":1,"highlight_end":37},{"text":"                for col in 0..length {","highlight_start":1,"highlight_end":39},{"text":"                    if self.rtc[row][col] {","highlight_start":1,"highlight_end":44},{"text":"                        count += 1;","highlight_start":1,"highlight_end":36},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                self.g.push(count);","highlight_start":1,"highlight_end":36},{"text":"                count = 0;","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn compute_handles(&mut self) {","highlight_start":1,"highlight_end":36},{"text":"        let mut final_handle: Matrix;","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let first_p = matrix::transitive_closure(&self.first);","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        final_handle = matrix::product(&self.equal, &first_p);","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.takes = final_handle.clone();","highlight_start":1,"highlight_end":43},{"text":"        final_handle.clear();","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let last_p = matrix::transitive_closure(&self.last);","highlight_start":1,"highlight_end":61},{"text":"        let identity = matrix::create_identity(10);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let first_s = matrix::sum(&identity, &first_p);","highlight_start":1,"highlight_end":56},{"text":"        let transpose = matrix::transpose(&last_p);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        final_handle = matrix::product(&transpose, &self.equal);","highlight_start":1,"highlight_end":65},{"text":"        final_handle = matrix::product(&final_handle, &first_s);","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.yields = final_handle.clone();","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"consider adding a `main` function to `src/main.rs`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0601]\u001b[0m\u001b[0m\u001b[1m: `main` function not found in crate `precedence`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:1:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::io::{self, BufRead};\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod boolean;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m330\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider adding a `main` function to `src/main.rs`\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0601`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0601`.\u001b[0m\n"}
